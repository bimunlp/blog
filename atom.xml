<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Deep Learning</title>
  
  <subtitle>深度学习</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-26T08:02:25.246Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>友邻君</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何训练人工神经网络？</title>
    <link href="http://yoursite.com/2019/01/26/%E5%A6%82%E4%BD%95%E8%AE%AD%E7%BB%83%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/01/26/如何训练人工神经网络？/</id>
    <published>2019-01-26T07:56:23.000Z</published>
    <updated>2019-01-26T08:02:25.246Z</updated>
    
    <content type="html"><![CDATA[<h4><span id="神经网络的训练">神经网络的训练</span></h4><p>这篇文章带大家学习如何训练一个人工神经网络．之前的文章中我们学习了如何构建一个简单的人工神经网络，当我们把一个神经网络配置好之后，下一步就是来训练它了．</p><a id="more"></a><!-- toc --><ul><li><a href="#什么是训练">什么是训练？</a><ul><li><a href="#优化算法">优化算法</a></li><li><a href="#损失函数">损失函数</a></li></ul></li><li><a href="#结论">结论</a></li></ul><!-- tocstop --><h3><span id="什么是训练">什么是训练？</span></h3><p>模型的训练过程，基本来说就是一个解决优化问题的过程，优化模型中的权重．我们的任务是找到最准确地将输入数据映射到正确输出类的权重。这种映射是网络<em>学习</em>而来的。</p><p>在关于层的介绍的那篇文章中我们提到了这个概念．我们在构建模型的时候，可以给这些节点的连接分配任意的权重，在训练中对这些权重进行迭代更新使其向最优值移动．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// pseudocode</span><br><span class="line">def train(model):</span><br><span class="line">    model.weights.update()</span><br></pre></td></tr></table></figure><h4><span id="优化算法">优化算法</span></h4><p>使用我们称之为优化算法(optimization algorithm)的方法来优化权重。不同的优化算法有不同的优化流程。我们用<em>优化器(optimizer)</em>一词来指代所选择的优化算法。最广为人知的优化器称为<em>随机梯度下降(stochastic gradient descent)</em>，或更简单地称为 SGD。</p><p>当处理优化问题时，必须先有一个优化目标，现在让我们考虑一下SGD在优化模型权重时的优化目标。</p><p> SGD的目标是优化一些给定的函数，这些函数被称为<em>损失函数</em>．SGD更新模型的权重，使得此损失函数尽可能接近其最小值。</p><h4><span id="损失函数">损失函数</span></h4><p>我们在模型优化中可以用的损失函数有很多，一个常见的损失函数是<em>均方误差</em>（MSE）。具体使用哪种损失函数是由我们在实践中决定的。现在，让我们先从一般层面认识一下损失函数，之后再更加详细地研究具体的损失函数。</p><p>我们所说的损失指的是什么？在训练过程中，我们给模型提供数据和数据相应的标签．</p><p>例如，假设我们想要训练一个用来分类图像中是猫的还是狗的模型。我们给这个模型提供猫和狗的图像，以及说明每个图是猫是狗的标签。</p><p>我们现在把一只猫的图像传递给模型，当猫的图像数据从网络中传递，前向传播结束后，模型会产生一个输出．这个输出包含了模型认为这个图像是猫是狗的信息．</p><p>具体来讲，这个输出反映的是图像是猫或是狗的概率．比如，模型给图像是猫分配７５％的概率，给图像是狗分配２５％的概率．在这种情况下，模型为图像是猫赋予更大的可能性．</p><ul><li>有75％的可能性是猫</li><li>25％的几率它是一只狗</li></ul><p>这其实跟人类的思维方式很类似，我们所有的判断都是基于猜想和预测．</p><p>所谓损失是神经网络对图像的猜测跟图像的标签之间的差距，SGD尝试最小化这种误差，使得模型猜测尽可能地精确．</p><p>在我们把所有的数据都传递给模型之后，我们会重复这一过程，让数据在模型中一次次传递．这种重复的数据传递就是训练．模型在训练的过程中能够＂学到＂很多信息，我们在下一篇文章会详细介绍．SGD通过反复的迭代，最终能够从数据中学习．</p><h3><span id="结论">结论</span></h3><p>我们现在已经了解到数据在网络中前向传播的过程中大致发生了什么．在下一篇文章中我们会介绍模型是怎样通过多次前向传播学习的，以及SGD最小化损失函数的具体方法．</p><p>这篇文章提到了很多新的概念，例如优化器，损失，我们会在以后的文章中分开来讲这些内容．记得去查看我们最新的博文．</p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;神经网络的训练&quot;&gt;&lt;a href=&quot;#神经网络的训练&quot; class=&quot;headerlink&quot; title=&quot;神经网络的训练&quot;&gt;&lt;/a&gt;神经网络的训练&lt;/h4&gt;&lt;p&gt;这篇文章带大家学习如何训练一个人工神经网络．之前的文章中我们学习了如何构建一个简单的人工神经网络，当我们把一个神经网络配置好之后，下一步就是来训练它了．&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ANNs" scheme="http://yoursite.com/tags/ANNs/"/>
    
      <category term="人工神经网络" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="训练" scheme="http://yoursite.com/tags/%E8%AE%AD%E7%BB%83/"/>
    
  </entry>
  
  <entry>
    <title>如何理解神经网络中的激活函数(ativation functions)?</title>
    <link href="http://yoursite.com/2019/01/26/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-ativation-functions/"/>
    <id>http://yoursite.com/2019/01/26/如何理解神经网络中的激活函数-ativation-functions/</id>
    <published>2019-01-26T03:18:07.000Z</published>
    <updated>2019-01-26T08:06:20.983Z</updated>
    
    <content type="html"><![CDATA[<p>神经网络中的激活函数</p><p>这篇文章向大家解释激活函数到底是什么，以及如何在神经网络中使用激活函数．我会向大家介绍几种常见的激活函数，向大家展示这些激活函数如何在Keras中以代码的形式呈现．</p><a id="more"></a><p>上篇文章在介绍神经网络中层的概念的时候，已经提到过激活函数，它们经常出现在层之后，我们这节就更加深入地认识这个概念．</p><!-- toc --><ul><li><a href="#什么是激活函数">什么是激活函数？</a></li><li><a href="#激活函数有什么作用">激活函数有什么作用？</a><ul><li><a href="#sigmoid激活函数">Sigmoid激活函数</a></li><li><a href="#激活函数的由来">激活函数的由来</a></li><li><a href="#relu激活函数">Relu激活函数</a></li><li><a href="#为什么要使用激活函数">为什么要使用激活函数？</a></li><li><a href="#关于relu函数是非线性的证明">关于Relu函数是非线性的证明</a></li><li><a href="#在keras中用代码表示激活函数">在Keras中用代码表示激活函数</a></li></ul></li></ul><!-- tocstop --><h3><span id="什么是激活函数">什么是激活函数？</span></h3><p>让我们给出一个激活函数的定义：</p><blockquote><p>在人工神经网络中，激活函数是将节点的输入映射到其对应输出的函数。</p></blockquote><p>在上篇文章的图示中我们已经看到，层中的每个节点会得到每个传入连接的加权和，之后将这个加权和传递给激活函数．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node output = activation(weighted sum of inputs)</span><br></pre></td></tr></table></figure><p>激活函数执行某种类型的操作以将总和转换为通常在某个下限和某个上限之间的数字。这种转变通常是非线性转换。我们在以后会再次提到这种非线性变换．</p><h3><span id="激活函数有什么作用">激活函数有什么作用？</span></h3><p>激活函数的这种变换意义在哪里？激活函数是受什么启发？为了更好地理解激活函数，首先带大家看几个激活函数的例子．</p><h4><span id="sigmoid激活函数">Sigmoid激活函数</span></h4><p>Sigmoid函数接受输入并执行以下操作：</p><ul><li>对于负输入，sigmoid会将输入转换为接近零的数字。</li><li>对于正输入，sigmoid会将输入转换为接近1的数字。</li><li><p>对于接近零的输入，sigmoid会将输入转换为0到1之间的某个数字。</p><p><img src="http://cdn.yiyouls.com/sigmoid.svg" alt=""></p></li></ul><p>可以看出，对于sigmoid函数，０是它的下界，１是它的上界．</p><p>我们现在理解了这样一个激活函数的数学功能，那激活函数到底是受到什么的启发？</p><h4><span id="激活函数的由来">激活函数的由来</span></h4><p>激活函数同样是受到大脑活动的生物学特征的启发，我们知道不同类型的刺激会使不同区域的神经元被激活．</p><p>例如当你问道一些令人愉悦的东西，像刚出炉的点心，你大脑中某些特定的神经元就会被激活．但是当你闻到一些难闻的东西，像发酸的牛奶，这样就会激活你大脑中另外一些区域的神经元．</p><p>在我们大脑的褶皱深处，某些神经元要么正在被激活，要么没有。这种情形可以用数学符号表示，我们用０表示未被激活，用１表示被激活。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">if (smell.isPleasant()) &#123;</span><br><span class="line">    neuron.fire();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用人工神经网络中的Sigmoid激活函数，我们把神经元转换到在0和1之间的数字，如果越接近1，神经元被激活得越多，而越接近０，神经元被激活得越少。</p><h4><span id="relu激活函数">Relu激活函数</span></h4><p>激活函数并不总是将输入转换为0到1之间的数字。我们现在看一下ReLU激活函数．</p><p>ReLU作为目前最广泛使用的激活函数之一，它将输入转换为输入值本身与０之间更大的那个．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReLU(x) = max(0, x)</span><br></pre></td></tr></table></figure><p>因此，如果输入小于或等于零，则relu将输出零。如果输入大于零，则relu将输出输入值本身。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 伪代码</span><br><span class="line">function relu(x) &#123;</span><br><span class="line">    if (x &lt;= 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数背后的想法是，神经元越积极，被激活的就越多．</p><p>目前我们已经讨论了Sigmoid和relu函数，当然还有其他的一些类型的函数，它们会对输入做其他类型的变换．</p><h4><span id="为什么要使用激活函数">为什么要使用激活函数？</span></h4><p>要理解我们使用激活函数的原因，我们首先需要了解线性函数。</p><p>假设$f$是集合$X$上的函数 。  </p><p>假设$a$和$b$在$X$中。  </p><p>假设$x$是实数。 </p><p> 当且仅当以下情况时 ，函数 f被称为线性函数：</p><p> $f(a+b)=f(a)+f(b)$  并且　$f(xa)=xf(a)$</p><p>线性函数的一个重要特征是两个线性函数的组合也是线性函数。这意味着，即使在非常深的神经网络中，如果我们在前向传递过程中只对数据值进行线性变换，深度学习网络中从输入到输出的映射也将是线性的。</p><p>我们在深度学习神经网络中想要得到的映射往往要比线性映射复杂得多．</p><p>这个时候就需要用到激活函数了．大多数激活函数都是非线性的，这是我们有意为之的选择．具有非线性变换的激活函数允许神经网络计算任意复杂的函数。</p><h4><span id="关于relu函数是非线性的证明">关于Relu函数是非线性的证明</span></h4><p>如何证明Relu函数是非线性的．我们下面试着来证明Relu不是线性变换．</p><p>对于每个实数$x$，我们将函数$f$定义为：</p><p>$f(x)=relu(x)$</p><p>假设$a$是实数并且$a&lt;0$.</p><p>因为$a&lt;0$, 我们有，</p><p>$f(-1a)=max(0,-1a)&gt;0$  并且  $(-1)f(a)=(-1)max(0,a)=0$</p><p>由此可得，</p><p>$f(-1a)\ne (-1)f(a)$</p><p>由此证明函数$f$是非线性的．</p><h4><span id="在keras中用代码表示激活函数">在Keras中用代码表示激活函数</span></h4><p>现在我们学习如何在Keras顺序模型中指定一个激活函数</p><p>定义激活函数有两种基本的方式，首先需要导入类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers import Dense, Activation</span><br></pre></td></tr></table></figure><p>之后我们可以在层构造函数中指定激活函数，像这样，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential([</span><br><span class="line">    Dense(5, input_shape=(3,), activation=&apos;relu&apos;)</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>这样我们就有了一个<code>dense</code>类型的层，并且指定本层的激活函数为<code>activation=&#39;relu&#39;</code></p><p>第二种方法是在模型实例化之后将层和激活函数添加到我们的模型中，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential()</span><br><span class="line">model.add(Dense(5, input_shape=(3,)))</span><br><span class="line">model.add(Activation(&apos;relu&apos;))</span><br></pre></td></tr></table></figure><p>请记住</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node output = activation(weighted sum of inputs)</span><br></pre></td></tr></table></figure><p>在上面的例子中，<code>dense</code>层每个节点的输出等于输入加权和的relu值，即</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node output = relu(weighted sum of inputs)</span><br></pre></td></tr></table></figure><p>希望你现在可以对激活函数如何适用于神经网络结构有个大概的认识，能够了解它们的功能和作用，并且学会在Keras中调用它们．我们下篇文章再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;神经网络中的激活函数&lt;/p&gt;
&lt;p&gt;这篇文章向大家解释激活函数到底是什么，以及如何在神经网络中使用激活函数．我会向大家介绍几种常见的激活函数，向大家展示这些激活函数如何在Keras中以代码的形式呈现．&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ANNs" scheme="http://yoursite.com/tags/ANNs/"/>
    
      <category term="人工神经网络" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="激活函数" scheme="http://yoursite.com/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>如何理解神经网络中层(layer)的概念？</title>
    <link href="http://yoursite.com/2019/01/25/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E5%B1%82-layer-%E7%9A%84%E6%A6%82%E5%BF%B5%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/01/25/如何理解神经网络中层-layer-的概念？/</id>
    <published>2019-01-25T12:59:25.000Z</published>
    <updated>2019-01-26T03:19:38.053Z</updated>
    
    <content type="html"><![CDATA[<p>如何理解神经网络中层(layer)的概念?</p><p>我们在之前的文章中认识了只有三个层的神经网络，但在很多时候我们有多个隐藏层，这篇文章探讨如何深入理解神经网络中层的概念，并提供一个多层神经网络的构建方法．</p><a id="more"></a><!-- toc --><ul><li><a href="#神经网络的层">神经网络的层</a></li><li><a href="#为什么有不同类型的层">为什么有不同类型的层？</a></li><li><a href="#人工神经网络示例">人工神经网络示例</a><ul><li><a href="#层的权重">层的权重</a></li><li><a href="#神经网络正向传播">神经网络正向传播</a></li><li><a href="#找到最佳权重">找到最佳权重</a></li></ul></li><li><a href="#用keras代码定义神经网络">用Keras代码定义神经网络</a></li></ul><!-- tocstop --><h3><span id="神经网络的层">神经网络的层</span></h3><p><img src="http://cdn.yiyouls.com/cover_1.jpg" alt=""></p><p>为了更加深入地学习，我们需要更好地理解人工神经网络中层的概念，以及如何在keras中给一个顺序模型添加更多的层．</p><p>上篇文章我们学习了ANN中的神经元是如何组织成层结构的．我们用了一个<code>dense</code>层的例子，这是一种全连接．当然，层的类型不止这一种，keras中有各种各样的层类型：</p><ul><li>Dense层（全连接层）</li><li>卷积(convolutional)层</li><li>池化(pooling)层</li><li>递归(recurrent)层</li><li>正则化(normalization)层</li></ul><h3><span id="为什么有不同类型的层">为什么有不同类型的层？</span></h3><p>不同的层对其输入执行不同的转换，并且某些层比其他层更适合某些特定任务。例如，卷积层通常用于处理图像数据的模型中。递归层用于处理时间序列数据的模型，完全连接层（顾名思义）将每个输入完全连接到其图层中的每个输出。</p><p>这篇文章将继续从宏观层面理解层的概念，随着我们对深度学习认识的深入，我们会更加了解特定层类型的特殊作用．</p><h3><span id="人工神经网络示例">人工神经网络示例</span></h3><p>我们一起来看下面例子中的ANN模型：</p><p><img src="http://cdn.yiyouls.com/4layers.png" alt=""></p><p>对于这个例子，第一层，即输入层，由八个节点组成，每个节点代表数据集中给定样本的某个要素．</p><p>我们可以知道，来自数据集的单个样本由八个维度组成．当我们从数据集中选择样本并将此样本传递给模型时，样本中包含的八个值中的每一个都将提供给输入层中的相应节点。</p><p>我们可以看到八个输入节点中的每一个都连接到下一层中的每个节点。</p><p>第一层和第二层之间的每个连接将来自前一节点的输出传送到接收节点的输入（从左到右）。中间有六个节点的两个层都是隐藏层，因为它们位于输入和输出层之间。</p><h4><span id="层的权重">层的权重</span></h4><p>每两个节点之间的连接都有一个相关的权重，这个权重是一个数字。</p><p>每个权重代表两个节点之间连接的强度。当网络在输入层中的给定节点处接收输入时，该输入通过连接传递到下一节点，并且输入将乘以分配给该连接的权重。</p><p>对于第二层的每个节点，计算每个传入连接的加权和。然后将该总和传递给激活函数，该激活函数对给定的总和执行某种类型的变换。例如，激活函数可以将和变换为0和1之间的数。实际转换将根据使用的激活函数而变化。更多关于激活功能的介绍之后会提到．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node output = activation(weighted sum of inputs)</span><br></pre></td></tr></table></figure><h4><span id="神经网络正向传播">神经网络正向传播</span></h4><p>一旦我们获得给定节点的输出，获得的输出就是作为输入传递给下一层节点的值。</p><p>重复此过程直到到达输出层。输出层中的节点数取决于我们可能的输出个数或预测类的数量。在示例中，我们的预测类有四个。</p><p>假设我们的模型的任务是对四种动物进行分类。输出层中的每个节点将代表四种可能性之一。例如，这些动物可以是猫，狗，马或牛。具体怎样分类取决于数据集中有多少个类。</p><p>对于来自数据集的给定样本，从输入层到输出层的整个过程称为网络的前向传播。</p><h4><span id="找到最佳权重">找到最佳权重</span></h4><p>在模型学习时，更新和优化所有连接的权重，使得输入数据点映射到正确的输出预测类。我们以后会学到更多关于此优化过程 。</p><p>我们已经对神经网络模型中层是如何工作的有了一个大致了解。现在让我们看看如何用Keras代码表示我们的模型。</p><h3><span id="用keras代码定义神经网络">用Keras代码定义神经网络</span></h3><p>在我们之前的讨论中，我们学习了如何使用Keras构建顺序模型。我们现在把它应用到本文中所讲的这个示例中。</p><p>我们从定义一个<code>Dense</code>对象数组开始，即定义各个层。然后将该数组传递给顺序模型的构造函数。</p><p>我们的神经网络是长这样：</p><p><img src="http://cdn.yiyouls.com/4layers.png" alt=""></p><p>鉴于此，我们有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layers = [</span><br><span class="line">    Dense(6, input_shape=(8,), activation=&apos;relu&apos;),</span><br><span class="line">    Dense(6, activation=&apos;relu&apos;),</span><br><span class="line">    Dense(4, activation=&apos;softmax&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>注意<code>Dense</code>数组中指定的第一个对象不是输入层。第一个<code>Dense</code>对象是第一个隐藏层。输入层被指定为第一个<code>Dense</code>对象构造函数中的参数。</p><p>输入层共有８个节点，因此输入层形状被指定为<code>input_shape=(8,)</code>，第一个隐藏层有六个节点，第二个隐藏层也是如此，输出层有四个节点。</p><p>我们通过<code>activation=&#39;relu&#39;</code>为两个隐藏层使用一个名为relu的激活函数，通过<code>activation=&#39;softmax&#39;</code> 为输出层使用一个名为softmax的激活函数。我们将在下一篇关于激活功能的文章中更详细地介绍这些功能。</p><p>完整代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers import Dense, Activation</span><br><span class="line"></span><br><span class="line">layers = [</span><br><span class="line">    Dense(6, input_shape=(8,), activation=&apos;relu&apos;),</span><br><span class="line">    Dense(6, activation=&apos;relu&apos;),</span><br><span class="line">    Dense(4, activation=&apos;softmax&apos;)</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">model = Sequential(layers)</span><br></pre></td></tr></table></figure><p>以上是如何在Keras中表示一个拥有四个层的神经网络。通过这篇文章的介绍，希望你能够对神经网络中有哪些层及其运行方式有一个大致的了解。我们下篇文章再见！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如何理解神经网络中层(layer)的概念?&lt;/p&gt;
&lt;p&gt;我们在之前的文章中认识了只有三个层的神经网络，但在很多时候我们有多个隐藏层，这篇文章探讨如何深入理解神经网络中层的概念，并提供一个多层神经网络的构建方法．&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ANNs" scheme="http://yoursite.com/tags/ANNs/"/>
    
      <category term="人工神经网络" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
      <category term="layer" scheme="http://yoursite.com/tags/layer/"/>
    
  </entry>
  
  <entry>
    <title>什么是人工神经网络ANNs</title>
    <link href="http://yoursite.com/2019/01/25/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9CANNs/"/>
    <id>http://yoursite.com/2019/01/25/什么是人工神经网络ANNs/</id>
    <published>2019-01-25T07:21:58.000Z</published>
    <updated>2019-01-25T07:37:05.632Z</updated>
    
    <content type="html"><![CDATA[<p>什么是人工神经网络(artificial neural network)?</p><p>在上一篇文章中我们把深度学习定义为机器学习的子领域，深度学习所用到的算法是受大脑神经网络的结构和功能的启发．因为这个浅显的的原因，深度学习中使用的模型被称为人工神经网络（ANN）。</p><a id="more"></a><!-- toc --><ul><li><a href="#人工神经网络图示">人工神经网络图示</a></li><li><a href="#keras顺序sequential模型">Keras顺序(sequential)模型</a></li></ul><!-- tocstop --><p><img src="http://cdn.yiyouls.com/cover_1.jpg" alt="cover_1"></p><p>让我们给人工神经网络下一个定义。</p><blockquote><p>人工神经网络是一种计算系统，由一系列以特定方式组织的单元(unit)组成，这些单元被称神经元(neurons)，它们的组织方式被称为层(layers)结构，不同层的神经元的连接形成所谓的网络．</p></blockquote><p>不同层的神经元之间的每个连接将信号从一个神经元传递到另一个神经元。接收到信号的神经元处理信号并向网络内与其连接的下游神经元发信号。注意，神经元通常也称为 <em>节点</em>(nodes)，同一层的节点之间无连接。</p><p>节点组合为层状结构，从广义的层面，每个ANN中有三种类型的层：</p><ol><li>输入层　input layer</li><li>隐藏层　hidden layer</li><li>输出层　output layer</li></ol><p>不同的层对其输入执行不同类型的转换。数据在神经网络中的流动从输入层开始，然后在隐藏层中移动，直到到达输出层。这被称为数据在网络中的前向传递。输入层和输出层之间的层被称为隐藏层。</p><p>现在让我们考察每种类型的层所包含的节点数量：</p><ol><li>输入层 - 输入数据的每个维度形成一个节点。</li><li>隐藏层 - 每个隐藏层的节点数可以任意指定。</li><li><p>输出层 - 每个输出结果形成一个节点。</p><p>现在我们已经对ANN的定义和结构有了一个大体概念，下面让我们试着用图示的方法来解释这些概念。</p></li></ol><h3><span id="人工神经网络图示">人工神经网络图示</span></h3><p>我们一起来分析下图所展示的一个神经网络:</p><p><img src="http://cdn.yiyouls.com/ann.png" alt=""></p><p>该ANN共有三层。左侧的图层是输入层，右侧的图层是输出层，中间的图层是隐藏层。每个层都由神经元（节点）组成，这里我们用圆圈表示这些节点，让我们数一数这个网络的每一层有多少个节点。</p><p> 每层中的节点数：</p><ol><li>输入层（左）：2个节点</li><li>隐藏层（中）：3个节点</li><li>输出层（右）：2个节点</li></ol><p>该网络在输入层中有两个节点，这告诉我们该网络的每个输入必须具有两个维度，例如<em>体重</em>和<em>身高</em>。</p><p>该网络在输出层中有两个节点，这告诉我们通过网络向前（从左到右）传递的每个输入都有两个可能的输出。例如， <em>偏胖</em>或 <em>偏瘦</em>可能是两个输出类。请注意，输出类也称为预测类。</p><p> 在掌握了这些理论知识之后，让我们看看如何在Keras中使用代码构建ANN。</p><h3><span id="keras顺序sequential模型">Keras顺序(sequential)模型</span></h3><p>在Keras，我们可以构建所谓的顺序模型。Keras将顺序模型定义为线性层结构的顺序堆栈。因为我们刚刚学到神经元的组织方式就是层结构，顺序模型刚好是我们所需要的。</p><p>Keras通过顺序模型实现人工神经网络的构造。那就让我们看看如何使用Keras构建一个非常简单的顺序模型。</p><p>首先，我们在Keras中导入所需的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from keras.models import Sequential</span><br><span class="line">from keras.layers import Dense, Activation</span><br></pre></td></tr></table></figure><p>然后，我们创建一个名为<code>model</code>的变量，将一个Sequential对象的实例赋值予它．</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">model = Sequential(layers)</span><br></pre></td></tr></table></figure><p>对于构造函数，我们传递一个<code>Dense</code>对象数组 。每个<code>dense</code>对象的调用即是每一个层。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">layers = [</span><br><span class="line">    Dense(3, input_shape=(2,), activation=&apos;relu&apos;),</span><br><span class="line">    Dense(2, activation=&apos;softmax&apos;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><em>dense</em> 这个词表示这些层的类型，也就是说我们构造的这些层都属于<code>dense</code>类型。<code>dense</code>是一种特殊类型的层，随着学习的深入，我们还会看到许多其他的类型。</p><p>现在，我们只需知道<code>dense</code>是ANN中最基本的层类型，并且<code>dense</code>层的每个输出是由它的输入所计算的。 </p><p>回看图示中从隐藏层到输出层的箭头，我们可以知道隐藏层中的每个节点都连接到输出层中的所有节点。这说明图示中的输出层是一个<code>dense</code>层。同样我们也可以看出隐藏层也是<code>dense</code>类型。</p><p>每层中传递给<code>dense</code>层构造函数的第一个参数表示该层一共有多少神经元。</p><p>输入形状参数 <code>input_shape=(2,)</code>告诉我们输入层有多少神经元，在这个例子中有两个神经元。</p><p>最后还有一个参数也就是说所谓的激活函数。</p><ol><li><code>activation=&#39;relu&#39;</code></li><li><code>activation=&#39;softmax&#39;</code></li></ol><p>在之后的文章中会详细介绍激活函数，现在你只需要知道激活函数是一种非线性函数，一般用在<code>dense</code>层之下．</p><p>以上是在keras中最简单的一个模型定义方法，如果想要了解更多关于keras的知识，请参考本博客关于keras的系列教程，这篇文章希望你可以了解ANN是什么，如何用keras构造一个神经网络．更进一步学习请关注下一篇博文．</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;什么是人工神经网络(artificial neural network)?&lt;/p&gt;
&lt;p&gt;在上一篇文章中我们把深度学习定义为机器学习的子领域，深度学习所用到的算法是受大脑神经网络的结构和功能的启发．因为这个浅显的的原因，深度学习中使用的模型被称为人工神经网络（ANN）。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="ANNs" scheme="http://yoursite.com/tags/ANNs/"/>
    
      <category term="人工神经网络" scheme="http://yoursite.com/tags/%E4%BA%BA%E5%B7%A5%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>11大最常用静态网站建站工具，你用过几个？</title>
    <link href="http://yoursite.com/2019/01/19/11%E5%A4%A7%E6%9C%80%E5%B8%B8%E7%94%A8%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E5%BB%BA%E7%AB%99%E5%B7%A5%E5%85%B7%EF%BC%8C%E4%BD%A0%E7%94%A8%E8%BF%87%E5%87%A0%E4%B8%AA%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/01/19/11大最常用静态网站建站工具，你用过几个？/</id>
    <published>2019-01-19T07:46:47.000Z</published>
    <updated>2019-01-19T07:59:01.170Z</updated>
    
    <content type="html"><![CDATA[<p>在进行下一步操作之前，你首先要明白，你通过我们上篇博文所介绍的方式建立的网站，是一种静态网站，这个是最近特别流行的静态网站搭建博客的技术，非常适合让站长专注于内容创作而非网站本身的维护．</p><p>为什么不用动态网站例如大名鼎鼎的wordpress呢？</p><a id="more"></a><p>究其原因，还是与博客类型网站本身的定位有关．静态网站和动态网站相比有如下好处：</p><ul><li>免费。静态网站占用的系统资源少。如果挂到github pages上，只要注册一个域名就可以了。</li><li>高速。不经过php解析器，不用数据库，速度比动态网站快</li><li>安全。由于静态网站的简洁，免疫很多web攻击方式。</li><li>服务器端配置简单。只需要一个web server（apache、nginx）。</li><li>非常容易维护。静态网站生成工具能从简单的纯文本文件生成一个网站/博客。尤其是对Markdown文法的支持，可以让你非常快捷地生成图文并茂的博文．</li></ul><p>关于Markdown语法，我会用专门的一篇博文来介绍Tyora下怎么使用．不单单是写博文，各种各样的文字工作用上Markdown语法后，可以让你的效率和创造力倍增．</p><p>目前对于搭建静态网站，有很多有常用的开源工具．以下就是这些常用工具的介绍：</p><h1><span id="jekyll">Jekyll</span></h1><p><a href="http://jekyllrb.com/" target="_blank" rel="noopener"><strong>Jekyll</strong></a>做为GitHub Pages的构建工具（Ruby语言），使它成为最流行的静态网站生成工具。Jekyll的流行也因为它非常简单，只需要基础的web开发基础。你可以使用它轻易的把文本转换为自定义的网站/博客。</p><p>如果你有wordpress或其他博客站点，你可以导入到Jekyll中。Jekyll支持插件、标签等等。</p><p><img src="http://cdn.yiyouls.com/jekyll.png" alt="Jekyll"></p><blockquote><p>Github Pages：<a href="https://pages.github.com/" target="_blank" rel="noopener">https://pages.github.com</a></p><p>开始使用Jekyll：<a href="http://jekyllrb.com/docs/quickstart/" target="_blank" rel="noopener">http://jekyllrb.com/docs/quickstart/</a></p></blockquote><h1><span id="octopress">Octopress</span></h1><p><a href="http://octopress.org/" target="_blank" rel="noopener"><strong>Octopress</strong></a>是基于Jekyll的博客生成工具，它简化了Jekyll的操作，可以让你更舒服的创作。Octopress的一大优势是它插件很多，并且兼容Jekyll的官方插件。</p><p>Octopress支持内建的社交平台（Twitter, Google+），Disqus评论和Google Analytics。</p><p><img src="http://cdn.yiyouls.com/octopress.png" alt="Octopress"></p><blockquote><p>Octopress的文档：<a href="http://octopress.org/docs/" target="_blank" rel="noopener">http://octopress.org/docs/</a></p></blockquote><h1><span id="hexo">Hexo</span></h1><p><a href="https://hexo.io/" target="_blank" rel="noopener"><strong>Hexo</strong></a>是用Node.js编写的博客框架。这个静态网站生成工具非常快，使用它构建一个完整的网站只需要几秒钟。Hexo支持所有的GitHub Markdown特性，并支持大多数Octopress插件。</p><p>从其他博客平台迁移到hexo非常容易。</p><p><img src="http://cdn.yiyouls.com/hexo.png" alt="Hexo"></p><blockquote><p>[Hexo的文档]<a href="https://hexo.io/docs/" target="_blank" rel="noopener">https://hexo.io/docs/</a></p></blockquote><h1><span id="hugo">Hugo</span></h1><p>[Hugo]<a href="http://gohugo.io/" target="_blank" rel="noopener">http://gohugo.io/</a>是另一个流行的静态网站生成工具，它是使用go语言编写，并且使用Markdown语法。官网对它的描述：</p><blockquote><p>This application does not depend on administrative privileges, databases, interpreters, or external libraries, and still works like a charm. Websites or blogs built with Hugo can be hosted on any web host including GitHub Pages, S3, and Dropbox.</p></blockquote><p><img src="http://cdn.yiyouls.com/hugo.png" alt="Hugo"></p><blockquote><p>开始使用Hugo：<a href="http://gohugo.io/overview/quickstart/" target="_blank" rel="noopener">http://gohugo.io/overview/quickstart/</a></p></blockquote><h1><span id="pelican">Pelican</span></h1><p><a href="http://getpelican.com/" target="_blank" rel="noopener"><strong>Pelican</strong></a>是使用Python编写的静态网站生成工具。它支持用reStructuredText, Markdown, 和AsciiDoc创作网站内容。Pelican支持Jinja模版引擎，结果是，它支持很多自定义主题。</p><p>gongneng<img src="http://cdn.yiyouls.com/Pelican.png" alt="Pelican"></p><blockquote><p>开始使用Pelican：<a href="http://docs.getpelican.com/en/3.6.3/install.html" target="_blank" rel="noopener">http://docs.getpelican.com/en/3.6.3/install.html</a></p></blockquote><h1><span id="middleman">Middleman</span></h1><p><a href="https://middlemanapp.com/" target="_blank" rel="noopener">Middleman</a> －中间人，又一个使用Ruby编写的静态网站生成工具。它提供怎么使用和自定义的文档，方便你自定义你的网站。</p><blockquote><p>Middleman is a static site generator using all the shortcuts and tools in modern web development.</p></blockquote><p><img src="http://cdn.yiyouls.com/middleman.png" alt="Middleman"></p><blockquote><p>开始使用Middleman：<a href="https://middlemanapp.com/basics/install/" target="_blank" rel="noopener">https://middlemanapp.com/basics/install/</a></p></blockquote><h1><span id="metalsmith">Metalsmith</span></h1><p><a href="http://www.metalsmith.io/" target="_blank" rel="noopener">Metalsmith</a>是简单、高效、pluggable静态网站生成工具，它使用nodejs编写。Metalsmith和其他工具的最大区别是它的所有东西都由插件处理，并且插件可以重用。只要决定网站的功能，然后找到相关插件，组合到一起，ok，ready to go!</p><p>Metalsmith也可以生成PDF、电子书、文档等等。</p><p><img src="http://cdn.yiyouls.com/metalsmith.png" alt="Metalsmith"></p><blockquote><p>开始使用Metalsmith：<a href="http://www.metalsmith.io/" target="_blank" rel="noopener">http://www.metalsmith.io/</a></p></blockquote><h1><span id="docpad">DocPad</span></h1><p><a href="http://docpad.org/" target="_blank" rel="noopener">DocPad</a>自带建立好的网站主架，允许你快速的建立功能完整的网站。这个工具支持CoffeeScript、Ruby、PHP、Stylus等等。</p><blockquote><p>DocPad removes limitations and closes the gap between experts and beginners. Designers and developers can create websites faster than ever before.</p></blockquote><p><img src="http://cdn.yiyouls.com/docpad.png" alt="DocPad"></p><blockquote><p>开始使用DocPad：<a href="http://docpad.org/docs/install" target="_blank" rel="noopener">http://docpad.org/docs/install</a></p></blockquote><h1><span id="wintersmith">Wintersmith</span></h1><p><a href="http://wintersmith.io/" target="_blank" rel="noopener">Wintersmith</a>是极简的、可扩展的静态网站生成工具，它使用Nodejs编写。它同样支持插件。Wintersmith的项目基于目录结构，可以方便的移植旧站点。</p><p><img src="http://cdn.yiyouls.com/wintersmith.png" alt="Wintersmith"></p><blockquote><p>开始使用Wintersmith：<a href="https://github.com/jnordberg/wintersmith#quick-start" target="_blank" rel="noopener">https://github.com/jnordberg/wintersmith#quick-start</a></p></blockquote><h1><span id="cactus">Cactus</span></h1><p><a href="https://github.com/koenbok/Cactus/" target="_blank" rel="noopener">Cactus</a>是使用Python和Django模版系统制作的静态网站生成工具。</p><p>Cactus的源码托管在github：</p><p><img src="http://cdn.yiyouls.com/cactus.png" alt="Cactus"></p><blockquote><p>开始使用Cactus：<a href="https://github.com/koenbok/Cactus/" target="_blank" rel="noopener">https://github.com/koenbok/Cactus/</a></p></blockquote><hr><h1><span id="hubpress">HubPress</span></h1><p><a href="http://hubpress.io/" target="_blank" rel="noopener">HubPress</a>是开源的web应用，使用它可以允许你创建一个基于GitHub Pages的博客。HubPress的使用非常简单，你只需要fork这个项目到你的github，然后修改配置文件就可以了。</p><p><img src="http://cdn.yiyouls.com/hubpress.png" alt="HubPress"></p><blockquote><p>开始使用HubPress：<a href="https://github.com/HubPress/hubpress.io" target="_blank" rel="noopener">https://github.com/HubPress/hubpress.io</a></p></blockquote><hr><p>对于到底为什么要用这一个工具而不是另外一个，每个人都能讲出一大推理由．hexo的确是它们当中较为突出并广受欢迎的．至于我为什么要用它，我不想在这里搜肠刮肚列出一系列炫酷的名词，我不得不说，我当初在选工具的时候并没有做太多的调研，没有在这一大推工具中犯选择困难症．当时在我面前的只有jekyll和hexo，而我在试用之后果断选择了hexo，在接下来的文章中我会告诉你原因．</p><p><img src="http://cdn.yiyouls.com/choice.gif" alt=""></p><p>如果你觉得哪个工具是你更加喜欢的，请在下方评论区中介绍并说明原因，我迫不及待想试试它们的功能．</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在进行下一步操作之前，你首先要明白，你通过我们上篇博文所介绍的方式建立的网站，是一种静态网站，这个是最近特别流行的静态网站搭建博客的技术，非常适合让站长专注于内容创作而非网站本身的维护．&lt;/p&gt;
&lt;p&gt;为什么不用动态网站例如大名鼎鼎的wordpress呢？&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="http://yoursite.com/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="静态网站" scheme="http://yoursite.com/tags/%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99/"/>
    
      <category term="建站工具" scheme="http://yoursite.com/tags/%E5%BB%BA%E7%AB%99%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>如何在Github上免费开通一个Github Page作为个人主页</title>
    <link href="http://yoursite.com/2019/01/19/%E5%A6%82%E4%BD%95%E5%9C%A8Github%E4%B8%8A%E5%85%8D%E8%B4%B9%E5%BC%80%E9%80%9A%E4%B8%80%E4%B8%AAGithub-Page%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E4%B8%BB%E9%A1%B5/"/>
    <id>http://yoursite.com/2019/01/19/如何在Github上免费开通一个Github-Page作为个人主页/</id>
    <published>2019-01-19T06:13:27.000Z</published>
    <updated>2019-01-20T07:31:22.445Z</updated>
    
    <content type="html"><![CDATA[<p>为什么要选择在Github上建站，原因很简单，它是免费的．</p><p>只要你按照下面的六步走，就可以轻轻松松发布自己的网站，你不需要有任何关于编程或者网站建设的基础知识．所有的前提只是，你要有一个github账号．</p><a id="more"></a><p><img src="http://cdn.yiyouls.com/show_the_stuff.jpeg" alt=""></p><p>少啰嗦，先看东西</p><p><img src="http://cdn.yiyouls.com/applepds.png" alt=""></p><p>iPhone显示效果</p><p>iPad显示效果</p><p>iMac显示效果</p><p>Macbook显示效果</p><hr><div class="alert warning"><p>看到这里，如果觉得这个风格不合胃口，你也可以选择可以提前离场，因为接下来的许多配置都将和这个主题相关．</p></div><p>希望不被打脸．．．</p><p><img src="http://cdn.yiyouls.com/slap.gif" alt=""></p><p>如果你喜欢这样的网站风格，想一步步照样配置（我会把源码给你），或者只是想从这篇教程中汲取自己所需要的东西，作为自己建站参考，你都会发现，这个系列博文是可以带给你很多有用的信息的．总之，希望大家能够各得其所，各取所需．</p><p>为了给大家做出详细的讲解和展示，我会使用一个新的终端设备，把自己的仓库清空，以一种推倒重来的方式再现整个建站过程．</p><p><img src="http://cdn.yiyouls.com/domino.gif" alt=""></p><p>当你下定决心要建站的时候，你就开始面临一系列的选择．我在上个文章中就已经提到了大家会面临的第一个分叉路口．对于一个想要搭建<strong>个人博客</strong>系统的新手，我坚定地建议你采用Github托管的方式，原因很简单，它是免费的．</p><p>假定大家都知道Github是个什么东西，并且对它有着一种类似信仰的原始崇拜．</p><p><img src="http://cdn.yiyouls.com/codeape.gif" alt=""></p><p>你可以在Github上免费开通<a href="https://pages.github.com" target="_blank" rel="noopener">Github Page</a>，为你个人或者你的项目建立一个网站．<a href="https://pages.github.com" target="_blank" rel="noopener">Github Page</a>官方网站上有详细的介绍和操作流程．让我们开始操作吧．</p><blockquote><p>第一步．创建存储库 (repository)</p></blockquote><p>转到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>并<a href="https://github.com/new" target="_blank" rel="noopener">创建一个</a>名为<em>username</em> .github.io <a href="https://github.com/new" target="_blank" rel="noopener">的新存储库</a>，其中<em>username</em>是你在GitHub上的用户名（或组织名称）。</p><p><img src="http://cdn.yiyouls.com/step1.png" alt=""></p><p>如果存储库的第一部分与您的用户名不完全匹配，则无法正常工作，因此请务必正确使用。</p><span class="highlight-text danger">*需要注意的是*</span><ol><li>在实际操作中你会发现，如果你有自己的独立域名，对新储存库的命名不需要遵循这么严格的规则．以我自己为例，我的Github用户名是yiyouls,　我给自己用来建立Github Page的新仓库命名为blog.　同样是可行的．</li><li>仓库属性也可以选择Public</li></ol><blockquote><p>第二步，进入储存库，转到设置(settings)</p></blockquote><p>在设置页面你可以对你的新储存库进行相关设置，你可以在这里设置你的GIthub Page特性，包括功能的开启与关闭，是否绑定定制域名(custom domain).</p><p><img src="http://cdn.yiyouls.com/pagedomain.png" alt=""></p><blockquote><p>第三步，下载使用Github桌面客户端(Github Desktop)</p></blockquote><p>GitHub Desktop是在macOS和Windows上使用Git和GitHub的好方法。（如果你不想使用Github客户端，你也可以直接在终端里通过<code>git</code>命令进行操作<sup><a href="#fn_1" id="reffn_1">1</a></sup>，我会把terminal的操作方法一并列出）</p><p><a href="https://desktop.github.com/" target="_blank" rel="noopener">下载GitHub桌面</a></p><p><img src="http://cdn.yiyouls.com/githubdesk.png" alt=""></p><blockquote><p>第四步，将储存库克隆到本地，用Github桌面客户端打开</p></blockquote><p>客户端完成安装后，返回我们刚建的储存库主页并刷新页面。单击“Set up in Desktop”按钮。当GitHub桌面应用程序打开时，保存项目。这样我们就把该储存库克隆到了本地．</p><span class="highlight-text danger">注意</span><ol><li><p>如果Github桌面客户端未能打开，你可以从电脑应用程序库找到它并启动，用户登录后，你可以看到你名下的所有储存库，找到我们新建的那个，手动克隆它．</p></li><li><p>如果你使用terminal操作，你首先需要<code>cd</code>到你准备存放你的项目的文件夹（一定要记得你存放的路径），通过下面的操作克隆你的刚建的储存库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/username/username.github.io</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://cdn.yiyouls.com/clone.png" alt=""></p><blockquote><p>第五步，创建索引文件</p></blockquote><p>到这里，你的储存库尚未添加任何文件，你的网站也相应地空空如也．你需要添加索引文件</p><figure class="codeblock codeblock--tabbed"><figcaption><a href="https://pages.github.com" target="_blank" rel="noopener">index.html</a><ul class="tabs"><li class="tab active">html</li></ul></figcaption><div class="tabs-content"><figure class="highlight html" style="display: block;"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">​    <span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>I'm hosted with GitHub Pages.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">​</span><br></pre></td></tr></tbody></table></figure></div></figure><p>这样，你就在你的网站上添加了一行”hello world”</p><span class="highlight-text danger">注意</span><p>如果是使用terminal操作，你需要<code>cd</code>进入克隆出的文件，然后向文件夹里添加内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd username.github.io</span><br><span class="line"></span><br><span class="line">echo &quot;Hello World&quot; &gt; index.html</span><br></pre></td></tr></table></figure><blockquote><p>第六步，提交和发布</p></blockquote><p>输入存储库，提交更改，然后按发布按钮。</p><span class="highlight-text danger">注意</span><ol><li><p>你克隆下来的储存库在本地，你可以通过Finder或者资源管理器找到它，把新文件放进去，Github客户端就能够读取到这些改变啦．</p></li><li><p>如果你使用terminal终端，可以用<code>push</code>推送操作进行发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git add --all</span><br><span class="line"></span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure></li></ol><p><img src="http://cdn.yiyouls.com/desktop-demo.gif" alt=""></p><p>到这里，你的网站就已经发布在了<em>username</em> .github.io这个网址．教程到此结束．</p><div class="alert success"><p>you made it!</p></div><p><img src="http://cdn.yiyouls.com/really.gif" alt=""></p><p>网站这么丑，能用它来干嘛</p><p><img src="http://cdn.yiyouls.com/ugly.gif" alt=""></p><p>的确是这样，我们的网站虽然已经发布，但它基本还是个没用的废物，因为到目前为止我们只给它添加了一个索引文件．如果想要实现更多丰富的功能（可能是一些必备的功能），你必须添加很多代码和文件进去．</p><p><img src="http://cdn.yiyouls.com/busy.gif" alt=""></p><p>那么问题来了，真的忍心让你一点点把所有功能实现的代码都敲进去吗？那么建站所耗费的时间成本也太大了．事实上，我们大可不必这样．我们的开源社区已经有了很多可爱的工具和框架供我们使用，免去我们许多许多繁杂的工作．</p><p><img src="http://cdn.yiyouls.com/foryou.gif" alt=""></p><p>那么下篇博文，我会跟大家介绍一些可以让你的网站瞬间高大上起来的那些可爱的开源工具．so stay tuned.</p><blockquote id="fn_1"><sup>1</sup>. 之所以要使用Githbub客户端，是因为它是一个非常便捷的git储存库管理工具，当我们开始使用jekyll这样的建站工具对网站进行功能升级的时候，单单通过终端显然是很麻烦的．<a href="#reffn_1" title="Jump back to footnote [1] in the text."> &#8617;</a></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么要选择在Github上建站，原因很简单，它是免费的．&lt;/p&gt;
&lt;p&gt;只要你按照下面的六步走，就可以轻轻松松发布自己的网站，你不需要有任何关于编程或者网站建设的基础知识．所有的前提只是，你要有一个github账号．&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="http://yoursite.com/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
      <category term="Github Page" scheme="http://yoursite.com/tags/Github-Page/"/>
    
  </entry>
  
  <entry>
    <title>使用hexo在Github上免费搭建功能丰富的个人博客网站</title>
    <link href="http://yoursite.com/2019/01/18/%E4%BD%BF%E7%94%A8hexo%E5%9C%A8Github%E4%B8%8A%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E5%8A%9F%E8%83%BD%E4%B8%B0%E5%AF%8C%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"/>
    <id>http://yoursite.com/2019/01/18/使用hexo在Github上免费搭建功能丰富的个人博客网站/</id>
    <published>2019-01-18T13:17:06.000Z</published>
    <updated>2019-01-19T07:01:28.802Z</updated>
    
    <content type="html"><![CDATA[<p>这个系列博文将带你一步步搭建起自己的个人博客网站，包含tranquilpeak主题模板配置，站内搜索，live2d插件，mathjax数学公式插件，＂千牛云＂云加速，＂畅言＂评论区添加，打赏设置等等高阶功能．</p><a id="more"></a><p>我会特别强调在配置过程中可能会遇到的各种坑，一些不应该出现的问题会让大家觉得焦头烂额，明明是跟大家一样一步步按教程走过来的，为什么还是会出现百思不得其解的错误．所以这也将会是一个详细的踩坑记录．</p><p><img src="http://cdn.yiyouls.com/what.gif" alt=""></p><p>我一共花了三天时间把所有功能配置齐全，其中大部分时间都在处理那些在网上找不到教程的个性化问题，例如，＂首页缩略图无法加载＂，＂浏览器Tab栏favicon图标不能显示＂，＂首页外链icon如何更改＂，＂云加速镜像网址与加速网址的区别＂等等问题，这些琐碎的bug耗费了我大量时间，让我走了不少弯路．我会在文章中尽可能列出你在建站的时候可能会遇到的种种问题．你也可以在我的文章下面留言，告诉我你还遇到了什么样的坑．</p><p><img src="http://cdn.yiyouls.com/sorry.gif" alt=""></p><p>本文中所讲的博客搭建方法能够让你完成一个功能丰富的个人博客网站，满足绝大部分的个人需求，并且，如果你按照这样的步骤走完，你可以完全零成本搭建自己的网站，所有的服务和插件都可以用到基本免费的版本．</p><p><img src="http://cdn.yiyouls.com/free.gif" alt=""></p><p>当然，如果需要个性化的定制，比如绑定自己域名（你要购买一个私有域名），或者数据流量过大（如果网站有那么大的流量，说明你的博客可以用来变现了，哈哈），你是需要为你的爱好买单的．当然对于那些有特殊需求和目的的专业用户或者企业，是不太适合我这里所介绍的hexo+Github的建站方式的．我在＂手把手＂教大家建立自己的博客网站的时候，会兼顾有个人域名的童鞋和没有个人域名的童鞋．不过，像千牛云／畅言这样的建站服务的前提是要求你有一个经过工信部备案的域名．如果你没有个人域名，就不能实现一些我会讲到的有趣功能．</p><p><img src="http://cdn.yiyouls.com/pity.gif" alt=""></p><p>我个人在建站的过程中搜索了无数篇的博文和教程，这些文章大多数都是琐碎的讲解，浅尝辄止，内容又经常是千篇一律．甚至有一些有博文作者的理解错误，我在参考这些文章的时候吃了不少的苦头．在我建站的过程中就暗暗告诉自己，等这一切都结束了，我一定要总结出自己所有的经验和教训，让后来人得以参考．当然，也有一些非常好的教程，在建站中给了我很大帮助和启发，没有它们，我是无论如何也无法把网站搭建起来的．纸上得来终觉浅，绝知此事要躬行．</p><p>it makes me feel like Caesar</p><p><img src="http://cdn.yiyouls.com/finalrest.gif" alt=""></p><p>相信大家建立个人博客的初衷都是为了好玩，不管你是一个文艺青年，想要分享自己的生活和热爱，或者你是个极客，想要拿博客网站练手，都可以把这个教程当做你走向更广阔世界的垫脚石，这篇文章能帮你认识很多有趣的方法和概念，快速掌握许多建站技能，希望每个人都能从中有所收获．要知道，保持好奇心是一个人永远年轻的秘诀．</p><p><img src="http://cdn.yiyouls.com/young.gif" alt=""></p><p>话不多说，让我们一起开始吧！希望你玩的开心．</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个系列博文将带你一步步搭建起自己的个人博客网站，包含tranquilpeak主题模板配置，站内搜索，live2d插件，mathjax数学公式插件，＂千牛云＂云加速，＂畅言＂评论区添加，打赏设置等等高阶功能．&lt;/p&gt;
    
    </summary>
    
      <category term="建站" scheme="http://yoursite.com/categories/%E5%BB%BA%E7%AB%99/"/>
    
    
      <category term="github" scheme="http://yoursite.com/tags/github/"/>
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
      <category term="建站" scheme="http://yoursite.com/tags/%E5%BB%BA%E7%AB%99/"/>
    
  </entry>
  
  <entry>
    <title>什么是深度学习？</title>
    <link href="http://yoursite.com/2019/01/16/No%202%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%EF%BC%9F/"/>
    <id>http://yoursite.com/2019/01/16/No 2 什么是深度学习？/</id>
    <published>2019-01-16T13:32:50.000Z</published>
    <updated>2019-01-18T13:51:00.079Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习与深度学习基础教程</p><p>这篇文章将要回答什么是深度学习这个问题．</p><p>整个系列课程会涵盖深度学习领域的众多主题，我们会用很多篇文章来充分解释这些课题，以及它们的应用领域和技术实现。</p><a id="more"></a><p><img src="http://cdn.yiyouls.com/cover_1.jpg" alt="cover_1"></p><!-- toc --><ul><li><a href="#深度学习概念解析">深度学习概念解析</a><ul><li><a href="#什么是深度学习">什么是深度学习？</a></li><li><a href="#深度学习中的深度指的是什么">深度学习中的＂深度＂指的是什么？</a></li></ul></li></ul><!-- tocstop --><p><img src="http://cdn.yiyouls.com/image_2.png" alt="image_2"></p><h2><span id="深度学习概念解析">深度学习概念解析</span></h2><h3><span id="什么是深度学习">什么是深度学习？</span></h3><p>这篇文章将要回答什么是深度学习这个问题．</p><p>整个系列课程会涵盖深度学习领域的众多主题，我们会用很多篇文章来充分解释这些课题，以及它们的应用领域和技术实现。</p><p>在这个深度学习系列中所有的文章按特定顺序发表，一些文章中某些概念是基于之前讨论过的概念之上，因此如果你还不熟悉我们正在使用的某些术语或示例，请务必查看先前的文章。</p><p>让我们给出深度学习的定义。</p><blockquote><p>深度学习是机器学习的一个子领域，它所使用的算法是由人类大脑神经网络结构和功能所启发。</p></blockquote><p>我们现在所讲的深度学习，同样采用从数据中学习的算法，就像我们在上一篇关于机器学习的文章中所讨论的那样。 然而，这里的学习算法或模型是基于大脑神经网络的结构和功能。</p><p>我们在深度学习中使用的神经网络不是真正的生物神经网络。 他们只是与生物神经网络共享一些特征，因此，我们称之为人工神经网络（ANNs）。</p><p>我们也经常使用其他术语来指代人工神经网络。 在深度学习领域，人工神经网络（ANN）这个术语有时候也用下面的一些表达：</p><ul><li>网络(net)</li><li>神经网络(neural net)</li><li>模型(model)</li></ul><p><img src="http://cdn.yiyouls.com/layers.png" alt="a simple artificial neural network or ANN"></p><h3><span id="深度学习中的深度指的是什么">深度学习中的＂深度＂指的是什么？</span></h3><p>要理解深度学习中的＂深度＂指的是什么，我们首先需要了解人工神经网络的结构。 我们会发现，深度学习使用了一种我们称之为深网(deep net)或深层人工神经网络(deep artificial neural network)的特殊人工神经网络。</p><p>在下一篇关于人工神经网络的文章中，我们将学习如何构建人工神经网络，这将为我们提供理解人工神经网络如何成为深度人工神经网络所需的知识。</p><p>现在，你需要了解以下内容：</p><ol><li>ANN是使用我们称之为神经元的方法构建的</li><li>人工神经网络中的神经元通过层(layer)的方法构建。</li><li>ANN中除了输入层(input layer)和输出层(output layer)之外的所有层都称为隐藏层(hidden layers)。</li><li>如果ANN具有多个隐藏层，则称该ANN为深度ANN</li></ol><p><img src="http://cdn.yiyouls.com/layers4.png" alt="deep neural network with 4 layers"></p><p>总结一下，深度学习使用具有多个隐藏层的ANN结构。 在学习过程中请牢记这一点，随着我们对深度学习理解的加深，我们会越来越明白这一点。 期待下个文章跟你相遇！</p><span class="highlight-text purple">公众微信：友邻学社关注获取更多内容</span><p><img src="http://cdn.yiyouls.com/qrcode.jpg" alt=""></p><div class="alert success"><p>You made it! keep up the good work ^_^</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习与深度学习基础教程&lt;/p&gt;
&lt;p&gt;这篇文章将要回答什么是深度学习这个问题．&lt;/p&gt;
&lt;p&gt;整个系列课程会涵盖深度学习领域的众多主题，我们会用很多篇文章来充分解释这些课题，以及它们的应用领域和技术实现。&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="deep learning" scheme="http://yoursite.com/tags/deep-learning/"/>
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>什么是机器学习？</title>
    <link href="http://yoursite.com/2019/01/16/No%201%20%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/01/16/No 1 什么是机器学习/</id>
    <published>2019-01-16T13:00:28.000Z</published>
    <updated>2019-01-18T13:49:35.167Z</updated>
    
    <content type="html"><![CDATA[<p>机器学习与深度学习基础教程－从零开始</p><p>本系列教程是为初学者定制，涵盖并解释了深度学习和人工神经网络的基本概念</p><a id="more"></a><p><img src="http://cdn.yiyouls.com/cover_1.jpg" alt="cover_1"></p><!-- toc --><ul><li><a href="#什么是机器学习">什么是机器学习？</a><ul><li><a href="#初识深度学习与人工神经网络">初识深度学习与人工神经网络</a></li><li><a href="#什么是机器学习-1">什么是机器学习？</a></li><li><a href="#机器学习-vs-传统编程">机器学习　v.s.　传统编程</a></li><li><a href="#更进一步深度学习">更进一步：深度学习</a></li></ul></li></ul><!-- tocstop --><p><img src="http://cdn.yiyouls.com/image_1.png" alt="image_1"></p><h2><span id="什么是机器学习">什么是机器学习？</span></h2><h3><span id="初识深度学习与人工神经网络">初识深度学习与人工神经网络</span></h3><p>本系列教程是为初学者定制，涵盖并解释了深度学习和人工神经网络的基本概念。</p><p>除了讲清基本概念，我们还展示了如何使用Keras（一种用Python编写的神经网络API）在代码中实现这些概念。 我们将学习人工神经网络中的层(layer)的概念，以及激活函数(activation function)，反向传播(backpropagation)，卷积神经网络（CNN），数据增强(data augmentation)，转移学习等概念。</p><p>我们通过讨论不同的术语，认识并理解它们的含义，搞清楚它们是如何适应整个深度学习框架的。 在某些章节里，我们会教大家如何在代码中实现一些课题。</p><p>我们会用Python编写的Keras神经网络API来进行演示，展示这些基本课题的技术实现。</p><p><img src="http://cdn.yiyouls.com/keras.png" alt="keras logo"></p><p>本网站有一个单独的系列专门介绍如何使用Keras，给大家作为重要参考。 Keras系列中的许多内容都假定你已经对本系列中将要讨论的深度学习知识有了基本的了解，请先浏览这个基础教程。</p><p>如果你想研究我们在本系列中所做的代码实现，可以转到Keras系列教程中了解Keras的预备知识，掌握这些先决知识，以便更好地使用Keras。</p><h3><span id="什么是机器学习">什么是机器学习？</span></h3><p>让我们从最基础的讲起。</p><p>深度学习是我们课程的核心概念，我们需要从基础着手更深入地认识它的含义。 在了解深度学习之前，我们首先要了解什么是机器学习。</p><blockquote><p>机器学习是使用算法分析数据，从该数据中学习，然后对新数据进行确定或预测的实践。</p></blockquote><p>这个概念听起来好像跟我们平常用写的代码差不多，似乎也是下面的路数：</p><ol><li>设计一个算法</li><li>机器在一个特定的数据集上执行这个算法</li><li>然后机器就可以在从未见过的新数据上再次执行这个任务</li></ol><p>都是给计算机下指令，那机器学习和我们平常写的逻辑算法区别在哪里呢？</p><p>根据我们刚刚给出的机器学习定义，重心是在＂从数据中学习＂这个部分．</p><blockquote><p>learn from data</p></blockquote><p>通过机器学习，而不是手动编写具有特定指令集的代码来完成特定任务，机器使用数据和算法进行训练，使其能够自主执行任务而无需明确告知如何执行任务。</p><p>现在这可能听起来像天方夜谭，但我们会在后面的文章中看到它是如何一步步实现的。 为了区别使用机器学习和传统编程来完成一项工作，我们看下面的示例。</p><p><img src="http://cdn.yiyouls.com/robot.jpg" alt="toy robot with a winder on its head and gears for ears (/home/scott/Documents/blog/source/_posts/robot%20machine.jpg)"></p><h3><span id="机器学习-vs-传统编程">机器学习　v.s.　传统编程</span></h3><p>示例：分析一个大众社交平台的评论，把这些评论分类为正面或负面情绪。</p><p><strong>传统的编程方法</strong><br>该算法可以首先查找与负面或正面情绪相关联的特定单词。</p><p>使用条件语句，算法会基于所查找到的正面或负面单词数目比例，将文章分类为正面或负面评价。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">let positive = [</span><br><span class="line">    <span class="string">"happy"</span>, </span><br><span class="line">    <span class="string">"thankful"</span>, </span><br><span class="line">    <span class="string">"amazing"</span></span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">let negative = [</span><br><span class="line">    <span class="string">"can't"</span>, </span><br><span class="line">    <span class="string">"won't"</span>, </span><br><span class="line">    <span class="string">"sorry"</span>, </span><br><span class="line">    <span class="string">"unfortunately"</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><p>这些词汇的选择是程序员任意指定的。 一旦我们得到正面和负面单词的列表，一个简单的算法就是简单地计算给定文章中每种类型单词的出现次数。 然后，基于正例或负例那种次数更多，可以将文章分类为正向或负向。</p><p><strong>机器学习方法</strong><br>该算法分析给定的媒体数据并学习能够将负面文章与正面文章分类的特征。</p><p>通过学到的知识，算法可以将新文章分类为正面或负面。 在这种情况下，设计机器学习程序不需要明确指定需要算法识别的单词。 相反，该算法将通过检验每篇文章的标签来“学习”某些单词是正面还是负面。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伪代码</span></span><br><span class="line">let articles = [</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">"positive"</span>,</span><br><span class="line">        data: <span class="string">"The lizard movie was great! I really liked..."</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">"positive"</span>,</span><br><span class="line">        data: <span class="string">"Awesome lizards! The color green is my fav..."</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">"negative"</span>,</span><br><span class="line">        data: <span class="string">"Total disaster! I never liked..."</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        label: <span class="string">"negative"</span>,</span><br><span class="line">        data: <span class="string">"Worst movie of all time!..."</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3><span id="更进一步深度学习">更进一步：深度学习</span></h3><p>在我们大概了解机器学习之后，就能够在此基础上认识深度学习。 深度学习是一种可用于实现机器学习的工具或技术。 下一节我们将详细介绍深入学习，敬请期待。 希望我们的文章可以帮到你！</p><span class="highlight-text purple">公众微信：友邻学社关注获取更多内容</span><p><img src="http://cdn.yiyouls.com/qrcode.jpg" alt=""></p><div class="alert success"><p>You made it! keep up the good work ^_^</p></div>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;机器学习与深度学习基础教程－从零开始&lt;/p&gt;
&lt;p&gt;本系列教程是为初学者定制，涵盖并解释了深度学习和人工神经网络的基本概念&lt;/p&gt;
    
    </summary>
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="machine learning" scheme="http://yoursite.com/tags/machine-learning/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
</feed>
